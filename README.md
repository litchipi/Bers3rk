# Bers3rk
A simple Bruteforce wrapper designed to create custom bruteforce sessions using a (very) small wordlist.
Useful if you already have hints on a password, directory fuzzing, etc...

## Usage
Bers3rk is a wrapper, so you must create your own script to use it.
It comes with defaults configurations that you can tweak and basically act at every stage of the bruteforce process.

``` python3
#!/usr/bin/env python3

from berserk import Berserk

WINS = ["hour", "p0kem0n", "Chocol4te", "MUS1C", "4Lpha"]

def fct_try(data, params):
"""
    Function called when trying a word
        Returns True if positive (right password, status code != 404 when fuzzing, etc ...)
        Returns False if negative
"""
      return data in WINS

with open("wordlist", "r") as fichier:
    data = fichier.read().split("\n")

brute = Berserk(fct_try, {})    # No particular parameters passed for this function
                                # We could have passed params for the fct_try function
                                #   through this dictionnary

brute.add_word_default_modif()  # Adds default modification on words to the list of modifications to try
                                #   (will try uppercase, lowercase, capitalize, A -> 4, E -> 3, etc ...)

brute.add_stop_condition(lambda r: all([w in r for w in WINS]))
                                # Function called with found results as argument,
                                #     if True will stop the bruteforce process
brute.run(data)     # Launches the bruteforce session
```

## Configuration
Here are the default configuration you can mess with:

``` python3
default_params = {
        "quit_on_first_success":False,  # If True, will stop bruteforcing after first success
        "save_sucessed_word":None,      # If not None: contains the filename in which save the results
        "nbsimilar":0,                  # 3 similars allowed -> will try "aaab" but not "aaaa"
        "joinchar":"",                  # Joint character between two words ("/" -> "a/b/c/d")
        "extensions":[],                # Extensions to try (when searching files)
                                        #   Will try data + suffix with no extensions, then data + extensions with no suffix
        "maxmix":2,                     # Number of different words to combine at the same time (3 -> will try "abc" but not "abcd")
        "suffix":"",                    # Suffix to add at the end of the word generated by the bruteforcer
        "prefix":"",                    # Prefix to add before the word generated by the bruteforcer
        "try_delay_ms":0.0,             # Time to wait between each try (avoid DDoS servers or burn our lovely computer) IN MS
        }
```



## Exemple of tool created with Bers3rk

This is originelly why I created this wrapper, I wanted a more powerfull fuzzer I could tweak how I wanted

``` python3
#!/usr/bin/env python3
import os
import requests
import argparse
import sys
from berserk import Berserk

def try_request(url, params):
    return (requests.get(url).status_code != 404)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--wordlist", "-w",
                        help="path to the wordlist file to use as fuzzing base")
    parser.add_argument("--url", "-u",
                        help="url to fuzz")
    parser.add_argument("--maxmix", "-m",
                        help="maximum number of element from wordlist to mix for a try",
                        default=2, type=int)
    parser.add_argument("--nbsimilar", "-n",
                        help="maximum similar words to use (ex: aaa -> 3 similar)",
                        default=0, type=int)
    parser.add_argument("--joinchar", "-j",
                        help="character used to join words of the wordlist before try",
                        default="", type=str)
    parser.add_argument("--outputfile", "-o",
                        help="File where to write every existing url found",
                        default="", type=str)
    parser.add_argument("--extensions", "-e",
                        help="Try with extensions (ex: py,html,php,js)",
                        default="", type=str)
    parser.add_argument("--suffix", "-s",
                        help="Add a suffix to the url to test",
                        default="", type=str)
    args = parser.parse_args()

    if not args.wordlist or not args.url:
        print("[!] Error: Can't run if no url and no wordlist")
        parser.print_help()
        sys.exit(0)
    if not os.path.isfile(args.wordlist):
        print("[!] Error: Can't fuzz without wordlist")
        parser.print_help()
        sys.exit(0)
    if not args.url:
        print("[!] Error: Can't fuzz without url")
        parser.print_help()
        sys.exit(0)

    params = dict()
    if args.outputfile != "":
        with open(os.path.abspath(args.outputfile), "w") as of:
            of.write("")
        params["save_sucessed_word"] = os.path.abspath(args.outputfile)

    with open(os.path.abspath(args.wordlist), "r") as wf:
        data = wf.read().split("\n")

    params["nbsimilar"] = args.nbsimilar
    params["joinchar"] = args.joinchar
    params["extensions"] = [el for el in args.extensions.split(",") if el != ""]
    params["maxmix"] = args.maxmix
    params["suffix"] = args.suffix
    params["prefix"] = args.url

    brute = BruteForcer(try_request, params)
    brute.add_word_default_modif()
    brute.add_stop_condition(lambda r: len(r) > 0)      # Find a particular page, quit after
    brute.run(data)
```

## TODO
* For now it runs on a single thread, a single process, and it's ok for my little bruteforces, but it may be a good idea to empower this.
* Outputs can't be disabled for now, used as a CLI tool but can't be "plugged" into another software for now as it will continue to output its TUI
